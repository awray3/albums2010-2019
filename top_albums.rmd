---
title: "Albums of the Decade, 2010 -- 2019"
author: "Andrew Wray"
date: "12/3/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align="center")
library("tidyverse")
library("ggplot2")
library("reshape2")
library("pander")
library("Hmisc")
library("knitr")

# For correspondence analysis
# library("FactoMineR")
# library("factoextra")


albums.data <- read_csv("data/AOTD_clean.csv")
albums.data$rank <- as.integer(albums.data$rank)
albums.data$year <- as.numeric(albums.data$year)
albums.data$reviewer <- as.factor(albums.data$reviewer)

albums.reviewers <- albums.data$reviewer %>% as.character() %>% unique
albums.reviewer_sym_pairs <- combn(albums.reviewers[albums.reviewers!="Time"], 2, simplify = TRUE, FUN=function(x) paste(x[1], x[2], sep=":"))
albums.reviewer_pairs <- expand.grid(albums.reviewers[albums.reviewers!="Time"], albums.reviewers[albums.reviewers!="Time"]) %>% filter(Var1!=Var2) %>% unite(pairs, sep=":") %>% {as.list(.)$pair}



albums.top_10 <- albums.data %>% filter(rank <= 10)
```


# Introduction {.tabset}

## Exploratory Data Analysis

```{r}
albums.num_artists <- length(unique(albums.data$artist))
albums.num_albums <- length(unique(albums.data$album))

```

```{r}
albums.data %>% filter(rank <= 10) %>% select(year) %>% 
  ggplot(aes(x=year)) + geom_histogram(aes(y=..density..), binwidth = 1)
```

```{r}
albums.data %>% select(year) %>% ggplot(aes(x=year)) + geom_histogram(aes(y=..density..), binwidth = 1)
```

```{r}
albums.top_10 %>% select(artist) %>% apply(MARGIN=2, table) 
```
So, Kendrick Lamar shows up the most in the top 10 most frequently.

```{r}
albums.top_10 %>% group_by(artist) %>% summarise(count=n()) 
```

## Are 2019 Albums underrepresented?

One way to do it: treat each year like a data point and view the counts for each year as a population. Then check if it is an outlier.
```{r}
albums.year_counts <- albums.data %>% group_by(year) %>% dplyr::summarize(count=n())
albums.counts_summary <- albums.year_counts$count %>% summary()

q1 <- albums.counts_summary["1st Qu."]
q3 <- albums.counts_summary["3rd Qu."]

albums.year_counts %>% filter(
  count < (q1 - 1.5*(q3-q1)) | count > (q3 + 1.5*(q3-q1))
)
``` 

Yep, 2019 definitely counts as an outlier according to the interquartile rule.

Another option: put a prior that albums follow a uniform prior for years. Then calculate the likelihood and posterior for this?

```{r, include=F}
# year_counts$cumsum <- cumsum(year_counts$count)
# year_counts %>% ggplot(aes(x = year, y = cumsum)) + geom_point()
```

## Metrics

Next we make a score based on the rank:

```{r}
# rank_cutoffs <- c(10, 20, 30, 40, 50, 100, 200)
# score_brackets <- c(10, 8, 5, 3, 2, 1, 0.5)
# # score_brackets <- (7:1)
# 
# rank_to_score <- function (rank) {
#   return(score_brackets[rank_cutoffs >= rank][1])
# }
# 
# albums$score <- sapply(albums$rank, rank_to_score)
# albums.album_scores <- (albums.data %>% group_by(artist, album) %>% summarize(total_score = sum(score))
# )
# 
# albums.artist_scores <- albums.album_scores %>% summarize(artist_score = sum(total_score)) %>% arrange(desc(artist_score))
```

Interesting results! Kendrick beats out Kanye in terms of raw score, but which artist's albums appear higher more often?

Want: number of each times each album appears in the top 10.
```{r, eval=FALSE}
# top_10_artists <- 
# top_10_artists$times_in_top_10 <- top_10 %>% group_by(artist, album) %>% summarize(count = n()) %>% summarize(total_count = sum(count)) %>% arrange(desc(total_count))
# 
# top_10_artists$total_score <- (
#   artist_scores %>% filter(artist %in% top_10$artist) %>% select(artist_score)
# )
```

## Who Dominates the top 10?

Ideas:
- Balloon plot with ranker on the x? Not sure
- Mosaic plot?
- Correspondence analysis?!
  - Have bins for rank (top 10, top 20, ...)
  - rows are artists, but observations are each album.
  - e.g. Kanye 1: MBDTF bins
         Kanye 2: Yeeyus bins ...
         https://www.mathematica-journal.com/2010/09/20/an-introduction-to-correspondence-analysis/




## Skillings-Mack tests {.tabset}

What if we turn the question on its head. Instead of asking "How did each album get rated by these reviewers?" we could instead take a list of albums and ask "How did the reviewers differ and correlate?"

```{r}
albums.pivot <- as_tibble(dcast(albums.data, artist+album ~ reviewer, value.var = 'rank'))

#get number of times each album appears in a list.
albums.pivot$times_rated <- length(albums.reviewers) - (
  albums.pivot %>% select(albums.reviewers) %>% is.na %>% rowSums
)

# 
albums.pivot$highest_rank <- (albums.pivot %>% select(albums.reviewers) %>% apply(1, FUN=min, na.rm=T))

rank_to_score <- function(n) {
  return(ifelse(is.na(n), 0, ifelse(n<=100, 101-n, 1)))
}

albums.scores <- albums.pivot
albums.scores[, albums.reviewers] <- albums.pivot %>% select(albums.reviewers) %>% apply(c(1,2), rank_to_score)
albums.scores$total <- albums.scores %>% select(albums.reviewers) %>% rowSums
```
This dataframe might be interesting on its own! I'm not sure if I had found a good way to do that earlier...


## Spearman Correlation {.tabset}
```{r func_def}
print_corr <- function(df, cor_only=TRUE) {
  cor_mat <- rcorr(as.matrix(df), type="spearman")
  
  if (cor_only) {
    return(kable(cor_mat$r))
  }
  else {
    return(cor_mat)
  }
}

```


### Understanding correlations of rankings 

First, here is a toy data frame. One ranker, say Pitchfork, gives a top 10 ranking. Then Genius almost agrees with Pitchfork, say, except they differ in one ordering (1 and 2). Then, say Time comes in with the completely opposite ranking. This is shown in the toy data below.
```{r}
toy_data <- tibble(Pitchfork=1:10, Genius=1:10, Time=10:1)
toy_data[1, "Genius"] = 2
toy_data[2, "Genius"] = 1

kable(toy_data)
toy_data %>% print_corr()
```

Passing this into `Hmisc::rcorr`, the resulting correlation tells us exactly what we think it should.

What if we now add in some rows that have some missing information in them?

```{r toy_add_NA}
toy_data[11, ] = c(12, 12, NA)

kable(toy_data)
toy_data %>% print_corr()
```

Adding one missing value with otherwise equal rankings does not change the correlation values. 


### Whole data
```{r spearman_corr_all_data}
albums.pivot %>% select(albums.reviewers) %>% print_corr(cor_only=TRUE)
```


Cool idea: plot the correlation values as a function of rank. In other words, for each integer $n$ from 1 to 100, calculate the correlation matrix. Plot its values. I expect it to start high ish and decay down to the values we see when including all ranks.

```{r}

get_corr <- function(dat, n) {
  # First get all rows of dat that contain at least one rank less than or equal to n.
  new_dat <- (dat %>% filter(highest_rank<=n) %>% select(albums.reviewers) %>% as.matrix)
  return(cor(new_dat, method="spearman"))
}


make_corr_table <- function(dat, min_rk, max_rk) {
  
  df <- tibble(n=min_rk:max_rk)
  df[albums.reviewer_pairs] <- NA
  
  for (i in (1:nrow(df))) {
    cor_mat <- get_corr(dat, df[[i,"n"]])
    
    for (j in 1:length(albums.reviewer_pairs)) {
      rev <- strsplit(albums.reviewer_pairs[j], ":")[[1]]
      df[i, albums.reviewer_pairs[j]] <- cor_mat[rev[1], rev[2]]
    }
    
  }
  
  return(df)
}
```

```{r}
albums.correlations <- albums.scores %>% 
  make_corr_table(1, 40) %>% 
  # as.data.frame() %>% 
  melt(id="n", 
       variable.name="reviewer_pair", 
       value.name="correlation") %>% 
  as_tibble

albums.correlations$reviewer_pair <- as.character(albums.correlations$reviewer_pair)

albums.correlations <- albums.correlations %>%
  separate(reviewer_pair, sep=":", into=c("reviewer_1", "reviewer_2"), remove=FALSE)
albums.correlations$reviewer_1 <- as.factor(albums.correlations$reviewer_1)
albums.correlations$reviewer_2 <- as.factor(albums.correlations$reviewer_2)

revs <- levels(albums.correlations$reviewer_1)
revs[revs=="Consequence of Sound"] <- "Consequence\n of Sound"
levels(albums.correlations$reviewer_1) <- revs
levels(albums.correlations$reviewer_2) <- revs
```

```{r}

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

ggplot(albums.correlations, aes(x=n, y=correlation, color=reviewer_1)) + 
  # geom_point() + 
  geom_line() + 
  facet_wrap("reviewer_2") + 
  scale_color_manual(values=cbbPalette)
  # guides(shape = guide_legend(ncol=1))
```

```{r}
ggplot(albums.correlations, aes(x=n, y=correlation)) + 
  geom_line() +
  facet_grid(vars(reviewer_1), vars(reviewer_2))

# https://stackoverflow.com/questions/38596658/multiple-plots-lay-out-as-upper-triangle-matrix-and-formatted-as-scatter-plots
# See there for a possible way to do upper half only

```




# Other ideas

Largest discrepancies

# Converting to Scores

Matt gave me an idea to convert the ranks into direct scores. Say rank 1 gets 100 points, rank 2 gets 99, and so on. (Later, maybe try categories instead, where top 10 get 90, top 20 get 80, and so on.)


